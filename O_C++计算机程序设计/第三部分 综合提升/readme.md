## 学习笔记 与 示例代码 
![65547bb2342c29717c1dc469d1e1e15](https://user-images.githubusercontent.com/68007558/178406242-5533f4c7-fac9-4c51-9fff-ac85bf73812c.jpg)

--
#### 第一关 ：

线性表的特性 :
- 线性表中必存在唯一的一个 “第一元素”
- 线性表中必存在唯一的一个 “最后元素”
- 除了最后一个元素，均有唯一的后继
- 除了第一个元素之外，均有唯一的前驱

线性表的一般操作：
- 将线性表变成空表
- 返回线性表的长度，即表中元素的个数;
- 获取线性表某位置的元素
- 定位某个元素再线性表中的位置
- 在线性表中插入一个元素
- 删除某个元素
- 判断线性表是否为空
- 遍历输出线性表中所有元素
- 线性表排序

![image](https://user-images.githubusercontent.com/68007558/178394312-f50fd952-03ec-4b45-b265-6bf532148cbc.png)

```cpp
// 定义结点结构  
struct node  
{  
    int data;     // 数据域  
    node * next;     // 指针域，指向下一个结点  
};  

```
C/C++ 提供了两种动态分配内存的方法：

C 语言提供的 malloc 和 free 函数，代码如下：

```CPP
node *t = (node *)malloc(sizeof(node));  
t->data = 2;  
free(t);  
```

C++ 扩展的 new 和 delete 运算符，代码如下：

```cpp
node *t = new node;  
t->data = 2;  
delete t;  
```


改成循环后，单链表里面可能包含0个或多个结点，如果包含多个结点，则下面程序中的语句可以让指针 t 指向链表的最后一个结点，具体代码如下

```cpp
node *t = head;     // t 指向第一个结点
// 如果 t->next 不为 NULL，即后面还有结点  
while(t->next != NULL)  
{  
    t = t->next;     // 把 t 指向结点的指针域（下一个结点地址）赋值给 t，t 指向下一个结点  
}  
// 循环结束时，t->next 为 NULL，即 t 指向的结点后面没有结点了。  
```

## 第五关 

####  遍历列表元素
在线性表中查找特定元素是线性表的常用操作之一。由于链表结点都是动态内存分配得到的，在内存中不是连续存储，没法使用二分法之类的算法来实现信息检索，但可以使用顺序查找的方法。

顺序查找需要遍历整个链表，逐个检查每个结点是否满足条件。下面 printList 函数则可以遍历链表元素：

// 函数printList：输出链表，每个数据之间用一个空格隔开  
// 参数：h-链表头指针  
```cpp
void printList(node *h)  
{  
    cout << "List:";  
    while(h)  
    {    // h 为真，即 h 指向的结点存在，则输出该结点的数据  
        cout << " " << h->data;     // 输出结点数据  
        h=h->next;     // 将该结点的指针域赋值给 h，h 就指向了下一个结点  
    }  
    cout << endl; // 输出换行符  
} 
```

