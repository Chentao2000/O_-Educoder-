## PCB 
#### PCB ( Process Control Block ) 进程控制块，或称 进程描述符：
- 它是进程存在的唯一标识，是操作系统用来记录 和 刻画进程状态以及环境信息的数据结构，是进程动态特征的汇集。
- 也是操作系统掌握进程的唯一资料结构和管理进程的主要依据。

----
#### 一般来说 PCB 包括以下三类信息：

1.  标识信息，标识信息用来唯一地标识一个进程，分为用户使用的外观标识 和 系统使用的内部标识 
2.  现场信息，现场信息用于保留进程在运行时存放在处理器现场中的各种信息
3.  控制信息，控制信息用于管理和调度进程，包括进程调度的信息 ↓
- ↑ （  进程状态，等待事件，等待原因，进程优先级，队列指针，进程组成信息..... )

-----
#### PCB 为什么？
- PCB 是操作系统最重要的数据结构，它包含管理进程所需要的全部信息
- PCB的集合实际上定义一个操作系统的当前状态，其使用权和修改权均属于操作系统 。
- （为什么） 系统在创建进程时就为它创建了PCB,当进程运行结束撤销时，回收其所占有的PCB
-  操作系统根据 PCB 对并发执行的进程进行控制和管理 ，进程依赖 PCB才被调度执行

## 死锁 ：

#### 死锁的定义： 
如果一个进程集合中的每个进程都在等待只能由此集合中的 其他进程才能引发的事件，而无限期陷入僵持的局面叫做死锁 

#### 死锁产生的条件：
- 互斥条件 ，临界资源是独享资源，进程应互斥且排他使用这些资源
- 占有和等待条件 ，进程在请求资源得不到满足而等待时候，不释放已有资源
- 不剥夺条件，又称为不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺
- 循环等待条件 ，又称环路条件，存在循环等待链
（前三条是 必要条件 ，最后一条是三条任一发生的必然结果）
#### 死锁防止策略：
（1）破坏条件1 （互斥条件）：

使资源可同时访问而非互斥 ，就没有进程会阻塞在资源上，从而不发生死锁

（2）破坏条件2 （占有和等待条件）

采用静态分配策略 ，进程在执行过程中不再申请资源，就不会出现占有某些资源再等待另一些资源的情况
（静态分配 是 指进程必须执行之前就申请需要的全部资源，且直到所要的资源都得到满足才执行）

（3）破坏条件3 (  不剥夺条件 )

剥夺调度能防止死锁，但只适用于内存和处理器资源

（4）破坏条件4（循环等待条件）

采用层次分配策略，将系统中所有资源排列到不同层次中；
- 一个进程得到某层的一个资源后，只能在申请较高一层的资源；
- 当进程释放某层的一个资源后，必须先释放所占用的较高层资源
- 当进程获取某层的一个资源后，如果向申请同层的另一个资源，必须先释放此层所占有的资源

#### 死锁的避免 ：

银行家算法 ：
（贼长 ，不会会用很简单）


#### 分页存储管理：

- 用分区方式管理存储器，每道程序要求占用内存的一个或多个连续的存储区域，导致内存中产生的碎片。

分页存储管理的基本原理：采用分页存储管理运行程序存放到若干个不相邻的空闲块

这样做 ：
1. 免除移动信息工作
2. 可充分利用内存空间
3. 消除动态分区法中的 “碎片”问题 ，从而提高内存空间的利用率


#### 分页存储涉及到的基本概念

##### 页面：
进程逻辑地址空间分成大小相等的区，每个区称为页面或页
##### 页框：
页框 又称页帧，把内存物理地址空间分成 大小相等的区，其大小与页面大小相等
##### 逻辑地址：
分页存储器的逻辑地址由页号和页内位移两部分组成 （格式如下） ：
```
页号          页内位移
```
##### 内存页框表：
该表的长度取决于内存划分的物理块数，编号可以与物理块号一致，页框表的表项给出物理块的使用情况

##### 页表：
采用动态重定位技术，让程序在执行时动态地进行地址变换，由于程序以页面为单位存储，所以每个页面设立一个重定位寄存器，这些重定位寄存器的集合被称为页表；

当CPU获取逻辑地址后，由硬件自动按设定的页面尺寸分为两个部分，页号p  和 页内位移d ,先从页表基址寄存器 找到 页表基地址，再用页号p作为索引查找页，页号p作为索引查找表：

得到最后的页框号： 根据关系式：

  ```
        物理地址 = 页框号 x 块长  + 页内偏移
  ```




### 分段存储管理

#### 程序分段结构：

（存储管理方式 从 固定分区 - > 动态分区 ：从分区方式向分页方式主要原因是：）

-   （分页存储管理方式）   提高内存空间的利用率
-   （分段存储管理方式） 满足用户（程序员）编程和使用上的要求

程序更多采用的是 分段结构，高级语言往往采用模块化程序设计的方法，应用程序由若干程序段（模块）组成，由：
 
 ```
 主程序段（M）  子程序段（X）   数据段（D） 工作区段（W）
 ```
 每段都有一个段号，段之间的程序不一定连续，段内地址是连续的，可见这是二维地址结构。
 
 #### 分段存储管理
 分段存储管理把进程的逻辑空间分成了好多段：提供如下形式的二维逻辑地址：
 ```
 段号   段内偏移
 ```
  
  -  在分页存储管理中，连续的地址空间根据页面大小自动分页
  -  在分段存储管理中，地址结构是可见的，用户知道逻辑地址如何划分成段内和段内偏移

分段存储管理的实现基于可变分区存储管理，可变分区以整个作业为单位来划分和连续存放

（也就是说：）
- 作业在分区内是连续存放的，但独立作业之间不一定连续存放

分段方法是以段为单位来划分和连续存放的，为作业的各段分配一个连续内存空间，而各段之间不一定连续


#### 分段和分页比较：

分段是信息的逻辑单位： 由源程序的逻辑结构及含义所决定的
- 是用户可见的 ，段长由用户根据需要来确定的，段起始地址可从任何内存地址开始
- 在分段方式中，源程序（段号，段内位移）经链接装配后 仍保持二维地址结构
- 引入目的的：满足用户模块化程序设计需要。

分页是信息的物理单元：与源程序的逻辑结构无关
- 是用户不可见的，页长由系统（硬件）确定
- 页面只能从页大小的整数倍地址开始
- 在分页方式中，源程序（页号、 页内偏移）经过链接装配后变成一维（地址）空间
- 引入目的是 ：实现离散分配并提高内存的利用率

 
 
 
 
 
 
 
 
 
 
 
 


















