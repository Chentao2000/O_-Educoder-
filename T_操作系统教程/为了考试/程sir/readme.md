 ## 连续存储 管理
 
 
 ### 分区存储管理：
  固定分区（fixed partition） 存储管理有称为静态分区模式

- 基本思想是 ：内存空间被划分成数目固定不变的分区，各个分区大小不等。
- 每个分区只装入一个作业，若多个分区都装有作业，则他们可以并发的执行。
- （↑ ↑这个就是支持多道程序设计最简单的存储管理技术 ）

（固定分区 是预先将内存分割成若干个连续区域，分割时各分区中按照地址顺序排列，那么其内存分配算法就十分简单 ！ ）


固定分区能够解决单道程序运行在并发环境下不能与CPU 速度匹配的问题，同时也解决了单道程序运行时内存空间利用率第低的问题！

但缺点是：
- 由于预先已规定分区的大小，使得大作业无法装入，用户不得不采用覆盖等技术加以补救，这样不旦加重了用户负担，且极不方便
- 内存空间利用率不高，作业很少会恰好填满分区
- 如果一个作业在运行过程中要求动态扩充内存空间，采用固定分区是相当困难的
- 分区数目是在系统初启时确定的，这就会限制多道运行程序的道数，特别不适应分时系统交互型用户内存需求变化很大的情况

（然而，固定方法实现简单，因此对程序大小和出现频率已知的情况还是比较合适的 ）


## 可变分区存储管理：

### 可变分区内存空间的分配和去配：

- 可变分区存储管理 又 称为 动态分区模式，按照作用大小来区分, 但划分的时间大小、空间、位置都是动态的。
- 系统把作业装入内存，根据其所需要的内存容量查看是否有足够空间，若有则需要分割一个分区分配给该作业； 若五则令此作业等待资源

#### 常用的可变分区算法

##### 最先适应分配算法
该算法按照顺序查找未分配区表或链表，直到找到第一个能满足长度要求的空闲区为止
-  采用这一分配算法，未分配区表或链表中的空闲区，通常按照地址从大到小排列。
-  进程分配内存空间时从低地址部分的空闲去查找， 可使高地址空间尽可能的少用，以保持一个大的空闲区
```
其优点： 有利于大作业的装入

其缺点：使得内存低地址和高地址两端分区不均衡 
```
##### 下次适应（next  fit） 算法
该算法总是从未分配区的上次扫描结束处顺序查找未分配区表或链表，直到找到第一个能满足长度要求的空闲区为止，分割这个未分配区。
- 一部分分配给作业，另一部分仍然为空闲去（若有）。
```
优点 是：这一类算法是最先适应分配算法的变种，能够缩短平均查找时间

缺点是 ： 且存储空间利用率会更加均衡。不会导致小空闲区集中与内存一端
```
##### 最优适应（best fit）算法
该算法扫描整个未分配区表或链表，从空闲区中挑选了一个满足用户进程要求的最小分区进行分配。
```
优点 ：此算法的内存利用率好，所找出的分区如果正好满足要求才是最合适的

缺点 ： 但如果比所要求的分区略大则分割后剩下的空闲区很小，难以利用，其查找时间也是最长的
```


##### 最坏适应（worst fit）算法
该算法扫描整个未分配区表或链表，总是挑选一个最大空闲区分割给作业使用  

采用该算法可把空闲区按长度递减顺序排列，查找时只需看第一个分区能否满足进程要求
```
优点是 ： 使剩下的空闲区不至于过小，对中小型作业有利

缺点是：查找时只需看第一个分区能否满足进程要求，使得查找的效率很高
```

##### 快速适应算法（quick fit ）分配算法：

该算法为那些经常用到的长度的空闲区设立单独的空闲区链表。

列如： 有一个n项 的表，该表的第一项 指向 2kb ，第二项指向 4 kb ，...

像 9 kb 这样的空闲区即可以放在8kb 链表中 也可以放在一个特殊的空闲区链表中。
```
优点 ： 此算法查找十分迅速，只要按进程长度直接搜索能容纳它的最小空闲区链表并取第一块分配

缺点 ： 归还内存空间时与相邻空间的合并即复杂又费时
```


## 内存不足的存储管理技术：

### 移动技术 

可变分区法中，必须把进程装入一个连续的内存区域，由于进程不断装入和撤销，导致内存常常出现分散的小空闲区 称为 “碎片”！
- 有时碎片 会小到小进程都容纳不下，这样不但浪费内存资源，还会限制调入内存的进程数目

当在未分配区表中找不到














